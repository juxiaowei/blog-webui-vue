<!DOCTYPE html>
<html>
<head><title>用Docker轻松搭建开发环境</title>
    <meta charset='utf-8'>
    <meta name="author" content="hades">
    <meta name="description" content="Powered by hades">
    <meta name="viewport"
          content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="x5-orientation" content="portrait">
    <meta name="screen-orientation" content="portrait">
    <link href='http://iamhades.oss-cn-shanghai.aliyuncs.com/md.css' rel='stylesheet'>
    <style></style>
</head>
<body>
<header id="header">
    <div class="article-title">
        用Docker轻松搭建开发环境
    </div>
    <div class="nav-toggle"><a href="#"><i class="fa fa-bars"></i></a></div>
</header>
<div class="web-content">
<div id='preview-contents' class='note-content'>
    <div id="wmd-preview" class="preview-content"></div>
    <div id="wmd-preview-section-5214" class="wmd-preview-section preview-content"></div>
    <div id="wmd-preview-section-5524" class="wmd-preview-section preview-content">

        <h5 id="用docker轻松搭建开发环境">用Docker轻松搭建开发环境</h5>

        <p>开发一个新项目，部署开发环境是第一步，但是会由于各种原因，导致配置开发环境很费时间，针对这种情况，其实可以轻松用docker来统一部署开发环境。详细如下：</p>

        <p>我们的每个项目都在Bitbucket上有自己的group,创建了一个名为development的分支。分支的同一层级有README.md(理论上)和docker-compose.yml两个文件。 <br>
            当新程序员加入项目时，只需在Bitbucket上浏览developmentrepository，根据README.md的步骤就可以快速搭建环境。具体步骤如下所示： </p>

    </div>
    <div id="wmd-preview-section-5525" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs smalltalk"><span class="hljs-comment line-number">1.</span><span
                class="hljs-char">$ </span>git -v <br><span class="hljs-comment line-number">2.</span><span class="hljs-char">$ </span>docker
            -v <br><span class="hljs-comment line-number">3.</span><span class="hljs-char">$ </span>docker-compose -v<br><span
                    class="hljs-comment line-number">4.</span><span class="hljs-char">$ </span>git clone git@bitbucket.<span
                    class="hljs-method">com:</span>&lt;project&gt;/development.git &lt;project&gt; &amp;&amp; cd &lt;project&gt; <br><span
                    class="hljs-comment line-number">5.</span><span class="hljs-char">$ </span>git submodule init &amp;&amp; git submodule
            update <br><span class="hljs-comment line-number">6.</span><span class="hljs-char">$ </span>git submodule foreach npm install <br><span
                    class="hljs-comment line-number">7.</span><span class="hljs-char">$ </span>docker-compose up -d <br></code></pre>

        <p>至此，一切就都已经搭建好，并运行在本地机器上了。</p>

    </div>
    <div id="wmd-preview-section-5526" class="wmd-preview-section preview-content">

        <h5 id="实现原理">实现原理</h5>

        <p>本章介绍我们是如何实现上述工作流的。 <br>
            前提条件 </p>

    </div>
    <div id="wmd-preview-section-5527" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs crystal"><span class="hljs-comment line-number">1.</span><span
                class="hljs-variable">$ </span>git -v <br><span class="hljs-comment line-number">2.</span><span
                class="hljs-variable">$ </span>docker -v <br><span class="hljs-comment line-number">3.</span><span
                class="hljs-variable">$ </span>docker-compose <br></code></pre>

        <p>
            由于我们的开发堆栈完全基于Docker，所以，程序员需要先安装Docker。这时他们不需要特别熟悉Docker，只需要在开发时使用Docker即可，我们间接地将他们引入到了容器的世界，之后会以此为桥梁向他们解释如何使用Docker实现持续集成、持续交付等等。README.md中并没有详细介绍如何安装Docker，因为安装很简单。</p>

        <p>当docker-compose还叫Fig的时候我们就已经用它来编排开发堆栈里的容器。之后Docker收购了Fig，重命名为Docker Compose。有人提议将Docker
            Compose合并到Docker代码里，但是基于很多原因最终并没有这么做，所以Docker Compose仍然需要单独安装。</p>

        <p>同样地，本文没有详细介绍Docker Compose的安装，因为很简单。 <br>
            搭建仓库（Repository） <br>
            如前所述，需要创建一个开发仓库，以及为每个应用创建对应的仓库。这里我们创建了api、dashboard和cpanel。当创建这些仓库的时候，重点关注development仓库的搭建。 <br>
            $ git clone git@bitbucket.com:＃project＃/development.git ＃project＃ &amp;&amp; cd <br>
            现在将应用程序的仓库添加为development仓库的子模块，只需要键入如下命令： </p>

    </div>
    <div id="wmd-preview-section-5528" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs stylus"><span class="hljs-comment line-number">1.</span>$ git submodule add
            git@bitbucket<span class="hljs-class">.org</span>:&lt;project&gt;/api<span class="hljs-class">.git</span> <br><span
                    class="hljs-comment line-number">2.</span>$ git submodule add git@bitbucket<span class="hljs-class">.org</span>:&lt;project&gt;/dashboard<span
                    class="hljs-class">.git</span> <br><span class="hljs-comment line-number">3.</span>$ git submodule add git@bitbucket<span
                    class="hljs-class">.org</span>:&lt;project&gt;/cpanel.git<br></code></pre>

        <p>这样，你的development仓库根目录下会创建出.gitmodules文件。程序员也就可以在克隆developmentrepository的时候一次得到所有的应用程序并运行： <br>
            <code>$ git submodule init &amp;&amp; git submodule update</code> <br>
            更多子模块的信息，请参考Git官方文档。</p>

    </div>
    <div id="wmd-preview-section-5529" class="wmd-preview-section preview-content">

        <h6 id="docker化一切">Docker化一切</h6>

        <p>现在我们已经搭建好了development仓库，可以通过cd的方式访问所有不同的应用程序。接下来我们要用之前提到的编排工具：Docker Compose来容器化所有的应用及其配置。 <br>
            首先从api应用程序开始。打开docker-compose.yml，为API声明一个容器，并为这个容器选择基础镜像。本示例中的代码基于Node.js，因此选择官方Node.js镜像：</p>

    </div>
    <div id="wmd-preview-section-5530" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs avrasm"><span class="hljs-comment line-number">1.</span><span class="hljs-label">api:</span><br><span
                class="hljs-comment line-number">2.</span><span class="hljs-label">image:</span> dockerfile/nodejs<br></code></pre>

        <p>这时，运行命令docker-compose up -d会创建出一个名为&lt;project&gt;_api_1的容器，这个容器什么也不做（启动后立即退出）。运行命令docker-compose
            ps可以得到由docker-compose.yml编排的所有容器的信息。接下来配置api容器，使其多一些功能。为了实现这个目的，我们需要：将源代码挂载到容器中，声明用什么命令运行应用，暴露合适的端口以供访问应用 <br>
            这样配置文件类似： </p>

    </div>
    <div id="wmd-preview-section-5531" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs groovy"><span class="hljs-comment line-number">1.</span><span
                class="hljs-string">api:</span><br><span class="hljs-comment line-number">2.</span><span class="hljs-string">image:</span>
            dockerfile/nodejs<br><span class="hljs-comment line-number">3.</span><span class="hljs-string">volumes:</span><br><span
                    class="hljs-comment line-number">4.</span>- .<span class="hljs-regexp">/api/</span>:<span class="hljs-regexp">/app/</span><br><span
                    class="hljs-comment line-number">5.</span><span class="hljs-string">working_dir:</span> <span
                    class="hljs-regexp">/app/</span><br><span class="hljs-comment line-number">6.</span><span
                    class="hljs-string">command:</span> npm start<br><span class="hljs-comment line-number">7.</span><span
                    class="hljs-string">ports:</span><br><span class="hljs-comment line-number">8.</span>- <span class="hljs-string">"8000:8000"</span><br></code></pre>

        <p>现在再运行docker-compose up -d，就启动了api应用，可以在<a href="http://localhost:8000" target="_blank">http://localhost:8000</a>访问它。这个程序可能会崩溃，可以使用docker-compose
            logs api检查容器日志。</p>

        <p>这里，我怀疑api的崩溃是因为它连不上数据库。因此需要添加database容器，并让api容器能够使用它。 </p>

    </div>
    <div id="wmd-preview-section-5532" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs groovy"><span class="hljs-comment line-number">1.</span><span
                class="hljs-string">api:</span> <br><span class="hljs-comment line-number">2.</span><span class="hljs-string">image:</span>
            dockerfile/nodejs <br><span class="hljs-comment line-number">3.</span><span class="hljs-string">volumes:</span> <br><span
                    class="hljs-comment line-number">4.</span>- .<span class="hljs-regexp">/api/</span>:<span class="hljs-regexp">/app/</span>
            <br><span class="hljs-comment line-number">5.</span><span class="hljs-string">working_dir:</span> <span
                    class="hljs-regexp">/app/</span> <br><span class="hljs-comment line-number">6.</span><span
                    class="hljs-string">command:</span> npm start <br><span class="hljs-comment line-number">7.</span><span
                    class="hljs-string">ports:</span> <br><span class="hljs-comment line-number">8.</span>- <span class="hljs-string">"8000:8000"</span>
            <br><span class="hljs-comment line-number">9.</span><span class="hljs-string">links:</span> <br><span
                    class="hljs-comment line-number">10.</span>- database <br><span class="hljs-comment line-number">11.</span><span
                    class="hljs-string">database:</span> <br><span class="hljs-comment line-number">12.</span><span
                    class="hljs-string">image:</span> postgresql <br><span class="hljs-comment line-number">13.</span><span
                    class="hljs-string">ports:</span><br><span class="hljs-comment line-number">14.</span>- <span class="hljs-string">"5432:5432"</span><br></code></pre>

        <p>通过创建database容器，并将其连接到api容器，我们就可以在api容器里找到database。要想展示API的环境（比如，console.log(process.env)），必须使用如下变量，比如<code>POSTGRES_1_PORT_5432_TCP_ADDR和POSTGRES_1_PORT_5432_TCP_PORT</code>。这是我们在API的配置文件里使用的关联到数据库的变量。
        </p>

        <p>通过link指令，这个数据库容器被认为是API容器的依赖条件。这意味着Docker Compose在启动API容器之前一定会先启动数据库容器。 <br>
            现在我们用同样的方式描述其它应用程序。这里，我们可以通过环境变量 <code>API_1_PORT_8000_TCP_ADDR和API_1_PORT_8000_TCP_PORT</code>，将api连接到dashboard和cpanel应用。 </p>

    </div>
    <div id="wmd-preview-section-5533" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs groovy"><span class="hljs-comment line-number">1.</span>- .<span
                class="hljs-regexp">/api/</span>:<span class="hljs-regexp">/app/</span> <br><span
                class="hljs-comment line-number">2.</span><span class="hljs-string">working_dir:</span> <span class="hljs-regexp">/app/</span>
            <br><span class="hljs-comment line-number">3.</span><span class="hljs-string">command:</span> npm start<br><span
                    class="hljs-comment line-number">4.</span><span class="hljs-string">ports:</span><br><span
                    class="hljs-comment line-number">5.</span>- <span class="hljs-string">"8000:8000"</span> <br><span
                    class="hljs-comment line-number">6.</span><span class="hljs-string">links:</span> <br><span
                    class="hljs-comment line-number">7.</span>- database <br><span class="hljs-comment line-number">8.</span><span
                    class="hljs-string">database:</span> <br><span class="hljs-comment line-number">9.</span><span
                    class="hljs-string">image:</span> postgresql <br><span class="hljs-comment line-number">10.</span><span
                    class="hljs-string">dashboard:</span> <br><span class="hljs-comment line-number">11.</span><span class="hljs-string">image:</span>
            dockerfile/nodejs <br><span class="hljs-comment line-number">12.</span><span class="hljs-string">volumes:</span> <br><span
                    class="hljs-comment line-number">13.</span>- .<span class="hljs-regexp">/dashboard/</span>:<span
                    class="hljs-regexp">/app/</span> <br><span class="hljs-comment line-number">14.</span><span class="hljs-string">working_dir:</span>
            <span class="hljs-regexp">/app/</span> <br><span class="hljs-comment line-number">15.</span><span
                    class="hljs-string">command:</span> npm start <br><span class="hljs-comment line-number">16.</span><span
                    class="hljs-string">ports:</span> <br><span class="hljs-comment line-number">17.</span>- <span class="hljs-string">"8001:8001"</span>
            <br><span class="hljs-comment line-number">18.</span><span class="hljs-string">links:</span> <br><span
                    class="hljs-comment line-number">19.</span>- api <br><span class="hljs-comment line-number">20.</span><span
                    class="hljs-string">cpanel:</span> <br><span class="hljs-comment line-number">21.</span><span
                    class="hljs-string">image:</span> dockerfile/nodejs <br><span class="hljs-comment line-number">22.</span><span
                    class="hljs-string">volumes:</span> <br><span class="hljs-comment line-number">23.</span>- .<span class="hljs-regexp">/api/</span>:<span
                    class="hljs-regexp">/app/</span> <br><span class="hljs-comment line-number">24.</span><span class="hljs-string">working_dir:</span>
            <span class="hljs-regexp">/app/</span> <br><span class="hljs-comment line-number">25.</span><span
                    class="hljs-string">command:</span> npm start <br><span class="hljs-comment line-number">26.</span><span
                    class="hljs-string">ports:</span> <br><span class="hljs-comment line-number">27.</span>- <span class="hljs-string">"8002:8002"</span>
            <br><span class="hljs-comment line-number">28.</span><span class="hljs-string">links:</span> <br><span
                    class="hljs-comment line-number">29.</span>- api <br></code></pre>

        <p>就像之前为数据库修改API配置文件一样，可以为dashboard和cpanel应用使用类似的环境变量，从而避免硬编码。 <br>
            现在可以再次运行docker-compose up -d命令和docker-compose ps命令：</p>

    </div>
    <div id="wmd-preview-section-5534" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs elixir"><span class="hljs-comment line-number">1.</span>kytwb<span
                class="hljs-variable">@continuous</span><span class="hljs-symbol">:~/path/to/&lt;project&gt;</span><span
                class="hljs-variable">$ </span>docker-compose up -d<br><span class="hljs-comment line-number">2.</span><span
                class="hljs-constant">Recreating </span>&lt;project&gt;<span class="hljs-constant">_database_1.</span>..<br><span
                class="hljs-comment line-number">3.</span><span class="hljs-constant">Recreating </span>&lt;project&gt;<span
                class="hljs-constant">_api_1.</span>..<br><span class="hljs-comment line-number">4.</span><span
                class="hljs-constant">Creating </span>&lt;project&gt;<span class="hljs-constant">_dashboard_1.</span>..<br><span
                class="hljs-comment line-number">5.</span><span class="hljs-constant">Creating </span>&lt;project&gt;<span
                class="hljs-constant">_cpanel_1.</span>..<br><span class="hljs-comment line-number">6.</span>kytwb<span class="hljs-variable">@continuous</span><span
                class="hljs-symbol">:~/path/to/&lt;project&gt;</span><span class="hljs-variable">$ </span>docker-compose ps<br><span
                class="hljs-comment line-number">7.</span><span class="hljs-constant">Name </span> <span class="hljs-constant">Command </span>
            <span class="hljs-constant">State </span> <span class="hljs-constant">Ports </span> <br><span
                    class="hljs-comment line-number">8.</span>----------------------------------------------------------------------------------<br><span
                    class="hljs-comment line-number">9.</span>&lt;project&gt;<span class="hljs-constant">_api_1 </span> npm start <span
                    class="hljs-constant">Up </span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span
                    class="hljs-number">0</span>.<span class="hljs-number">0</span><span class="hljs-symbol">:</span><span
                    class="hljs-number">8000</span>-&gt;<span class="hljs-number">8000</span>/tcp<br><span class="hljs-comment line-number">10.</span>&lt;project&gt;<span
                    class="hljs-constant">_dashboard_1 </span> npm start <span class="hljs-constant">Up </span> <span
                    class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span
                    class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">8001</span>-&gt;<span
                    class="hljs-number">8001</span>/tcp<br><span class="hljs-comment line-number">11.</span>&lt;project&gt;<span
                    class="hljs-constant">_cpanel_1 </span> npm start <span class="hljs-constant">Up </span> <span
                    class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span
                    class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">8002</span>-&gt;<span
                    class="hljs-number">8002</span>/tcp<br><span class="hljs-comment line-number">12.</span>&lt;project&gt;<span
                    class="hljs-constant">_database_1 </span> /usr/local/bin/run <span class="hljs-constant">Up </span> <span
                    class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span
                    class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">5432</span>-&gt;<span
                    class="hljs-number">5432</span>/tcp<br></code></pre>

        <p>应用应该就已经启动并运行了。 <br>
            从<a href="http://localhsot:8000" target="_blank">http://localhsot:8000</a>可以访问api。 <br>
            从<a href="http://localhsot:8001" target="_blank">http://localhsot:8001</a>可以访问dashboard。 <br>
            从<a href="http://localhsot:8002" target="_blank">http://localhsot:8002</a>可以访问cpanel。 </p>

    </div>
    <div id="wmd-preview-section-5535" class="wmd-preview-section preview-content">

        <h5 id="更进一步">更进一步</h5>

    </div>
    <div id="wmd-preview-section-5536" class="wmd-preview-section preview-content">

        <h5 id="本地路由">本地路由</h5>

        <p>在使用<code>docker-compose up -d</code>运行所有容器之后，可以通过<a href="http://localhost" target="_blank">http://localhost</a>:访问我们的应用。基于当前配置，我们可以很容易地使用jwilder/nginx-proxy加上本地路由功能，这样就可以使用和生产环境类似的URL访问本地应用了。比如，通过<a
                href="http://api.domain.local" target="_blank">http://api.domain.local</a>访问<a href="http://api.domain.com" target="_blank">http://api.domain.com</a>的本地版本。
            <br>
            jwilder/nginx-proxy镜像将一切变得很简单。只需要在docker-compose.yml里加上描述去创建一个名为nginx的新容器。根据jwilder/nginx-proxy的README文件（挂载Docker守护进程socket，暴露80端口）配置该容器就可以了。之后，在现有容器里再添加额外的环境变量VIRTUAL_HOST和VIRTUAL_PORT，如下：
        </p>

    </div>
    <div id="wmd-preview-section-5537" class="wmd-preview-section preview-content">

        <pre class="prettyprint hljs-dark"><code class="hljs haml"><span class="hljs-comment line-number">1.</span>api:<br><span
                class="hljs-comment line-number">2.</span>image: dockerfile/nodejs<br><span class="hljs-comment line-number">3.</span>volumes:<br><span
                class="hljs-comment line-number">4.</span>-<span class="ruby"> ./api/<span class="hljs-symbol">:/app/</span><br><span
                class="hljs-comment line-number">5.</span></span>working_dir: /app/<br><span class="hljs-comment line-number">6.</span>command:
            npm start<br><span class="hljs-comment line-number">7.</span>environment:<br><span
                    class="hljs-comment line-number">8.</span>-<span class="ruby"> <span class="hljs-constant">VIRTUAL_HOST</span>=api.domain.local<br><span
                    class="hljs-comment line-number">9.</span></span>-<span class="ruby"> <span
                    class="hljs-constant">VIRTUAL_PORT</span>=<span class="hljs-number">8000</span><br><span class="hljs-comment line-number">10.</span></span>ports:<br><span
                    class="hljs-comment line-number">11.</span>-<span class="ruby"> <span class="hljs-string">"8000:8000"</span><br><span
                    class="hljs-comment line-number">12.</span></span>links:<br><span class="hljs-comment line-number">13.</span>-<span
                    class="ruby"> database<br><span class="hljs-comment line-number">14.</span></span>database:<br><span
                    class="hljs-comment line-number">15.</span>image: postgresql<br><span class="hljs-comment line-number">16.</span>dashboard:<br><span
                    class="hljs-comment line-number">17.</span>image: dockerfile/nodejs<br><span class="hljs-comment line-number">18.</span>volumes:<br><span
                    class="hljs-comment line-number">19.</span>-<span class="ruby"> ./dashboard/<span
                    class="hljs-symbol">:/app/</span><br><span class="hljs-comment line-number">20.</span></span>working_dir: /app/<br><span
                    class="hljs-comment line-number">21.</span>command: npm start<br><span class="hljs-comment line-number">22.</span>environment:<br><span
                    class="hljs-comment line-number">23.</span>-<span class="ruby"> <span class="hljs-constant">VIRTUAL_HOST</span>=dashboard.domain.local<br><span
                    class="hljs-comment line-number">24.</span></span>-<span class="ruby"> <span
                    class="hljs-constant">VIRTUAL_PORT</span>=<span class="hljs-number">8001</span><br><span class="hljs-comment line-number">25.</span></span>ports:<br><span
                    class="hljs-comment line-number">26.</span>-<span class="ruby"> <span class="hljs-string">"8001:8001"</span><br><span
                    class="hljs-comment line-number">27.</span></span>links:<br><span class="hljs-comment line-number">28.</span>-<span
                    class="ruby"> api<br><span class="hljs-comment line-number">29.</span></span>cpanel:<br><span
                    class="hljs-comment line-number">30.</span>image: dockerfile/nodejs<br><span class="hljs-comment line-number">31.</span>volumes:<br><span
                    class="hljs-comment line-number">32.</span>-<span class="ruby"> ./api/<span class="hljs-symbol">:/app/</span><br><span
                    class="hljs-comment line-number">33.</span></span>working_dir: /app/<br><span class="hljs-comment line-number">34.</span>command:
            npm start<br><span class="hljs-comment line-number">35.</span>environment:<br><span
                    class="hljs-comment line-number">36.</span>-<span class="ruby"> <span class="hljs-constant">VIRTUAL_HOST</span>=cpanel.domain.local<br><span
                    class="hljs-comment line-number">37.</span></span>-<span class="ruby"> <span
                    class="hljs-constant">VIRTUAL_PORT</span>=<span class="hljs-number">8002</span><br><span class="hljs-comment line-number">38.</span></span>ports:<br><span
                    class="hljs-comment line-number">39.</span>-<span class="ruby"> <span class="hljs-string">"8002:8002"</span><br><span
                    class="hljs-comment line-number">40.</span></span>links:<br><span class="hljs-comment line-number">41.</span>-<span
                    class="ruby"> api<br><span class="hljs-comment line-number">42.</span></span>nginx:<br><span
                    class="hljs-comment line-number">43.</span>image: jwilder/nginx-proxy<br><span class="hljs-comment line-number">44.</span>volumes:<br><span
                    class="hljs-comment line-number">45.</span>-<span class="ruby"> /var/run/docker.<span class="hljs-symbol">sock:</span>/tmp/docker.sock<br><span
                    class="hljs-comment line-number">46.</span></span>ports:<br><span class="hljs-comment line-number">47.</span>-<span
                    class="ruby"> <span class="hljs-string">"80:80"</span></span><br></code></pre>

        <p>nginx容器会检查所有运行在Docker守护进程之上（通过挂载的docker.sock文件）的容器，为每个容器创建合适的nginx配置文件，并设置VIRTUAL_HOST环境变量。</p>

        <p>
            要想完成本地路由的搭建，还需要在etc/hosts里添加所有的VIRTUAL_HOST。我是手动用node.js的hostile包来完成这个工作的，不过我猜应该可以自动化实现，就像jwilder/nginx-proxy可以根据nginx配置文件动态变化一样。这里需要再研究一下。</p>

        <p>现在可以再次运行<code>docker-compose up -d</code>，然后使用和生产环境一样的url访问应用程序，只需用.localTLD代替.comTLD。</p></div>
    <div id="wmd-preview-section-footnotes" class="preview-content"></div>
</div>
</div>
<footer id="footer">
    <div class="copyright">© iAmHades - Blog . Article</div>

    <div class="post-back"><a href="#">‹ Back to Index</a></div>
</footer>

</body>
</html>